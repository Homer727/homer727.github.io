function Game() {
    const [game, setGame] = React.useState(initialGameState);
    const [selectedSquare, setSelectedSquare] = React.useState(null);
    const [player, setPlayer] = React.useState("White");
    const [isGameOver, setIsGameOver] = React.useState(false);
    const [timer, setTimer] = React.useState(0);
    const [intervalId, setIntervalId] = React.useState(null);

    // Timer function
    React.useEffect(() => {
        if (!isGameOver) {
            const id = setInterval(() => {
                setTimer((prev) => prev + 1);
            }, 1000);
            setIntervalId(id);

            return () => clearInterval(id); // Cleanup when the component unmounts
        } else if (isGameOver && intervalId) {
            clearInterval(intervalId);
        }
    }, [isGameOver]);

    // Format timer as MM:SS
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        const paddedMinutes = String(minutes).padStart(2, '0');
        const paddedSeconds = String(remainingSeconds).padStart(2, '0');
        return `${paddedMinutes}:${paddedSeconds}`;
    }

    function changePlayer() {
        setPlayer(player === "White" ? "Black" : "White");
        setTimer(0); // Reset timer for the next player
    }

    function forfeit() {
        setPlayer("Game Over! ".concat(player).concat(" loses!"));
        setIsGameOver(true);
    }

    function restartGame() {
        setGame(initialGameState);
        setPlayer("White");
        setTimer(0);
        setIsGameOver(false);  // Reset game over status
    }

    function canMove(piece, srcRow, srcCol, destRow, destCol) {
        const rowDiff = Math.abs(destRow - srcRow);
        const colDiff = Math.abs(destCol - srcCol);

        switch (piece.toLowerCase()) {
            case 'p':
                if (piece === 'P') {
                    if (srcRow === 6 && destRow === 4 && srcCol === destCol && !game[destRow][destCol]) {
                        return true;
                    } else if (destRow === srcRow - 1 && srcCol === destCol && !game[destRow][destCol]) {
                        return true;
                    } else if (destRow === srcRow - 1 && Math.abs(destCol - srcCol) === 1 && game[destRow][destCol] && game[destRow][destCol] === game[destRow][destCol].toLowerCase()) {
                        return true;
                    }
                } else {
                    if (srcRow === 1 && destRow === 3 && srcCol === destCol && !game[destRow][destCol]) {
                        return true;
                    } else if (destRow === srcRow + 1 && srcCol === destCol && !game[destRow][destCol]) {
                        return true;
                    } else if (destRow === srcRow + 1 && Math.abs(destCol - srcCol) === 1 && game[destRow][destCol] && game[destRow][destCol] === game[destRow][destCol].toUpperCase()) {
                        return true;
                    }
                }
                return false;
            case 'r':
                return srcRow === destRow || srcCol === destCol;
            case 'n':
                return rowDiff * colDiff === 2;
            case 'b':
                return rowDiff === colDiff;
            case 'q':
                return srcRow === destRow || srcCol === destCol || rowDiff === colDiff;
            case 'k':
                return rowDiff <= 1 && colDiff <= 1;
            default:
                return false;
        }
    }

    function checkPromotion(map, row, col) {
        if (map[row][col] === 'P' && row === 0) {
            map[row][col] = 'Q';
        } else if (map[row][col] === 'p' && row === 7) {
            map[row][col] = 'q';
        }
    }

    function makeMove(currentMap, destRow, destCol, selectRow, selectCol) {
        let map = currentMap.slice();
        const targetPiece = map[destRow][destCol];

        if (targetPiece.toLowerCase() === 'k') {
            setPlayer("Game Over! ".concat(player, " wins!"));
            setIsGameOver(true);
            clearInterval(intervalId);  // Stop the timer when the game ends
        } else {
            map[destRow][destCol] = map[selectRow][selectCol];
            map[selectRow][selectCol] = '';
            checkPromotion(map, destRow, destCol);
            setGame(map);
            changePlayer();
        }
    }

    function handleClick(row, col) {
        if (isGameOver) return;

        if (!selectedSquare) {
            if ((player === "White" && game[row][col] && game[row][col] === game[row][col].toUpperCase()) ||
                (player === "Black" && game[row][col] && game[row][col] === game[row][col].toLowerCase())) {
                setSelectedSquare([row, col]); // Select the piece
            }
        } else {
            const [selectedRow, selectedCol] = selectedSquare;
            const selectedPiece = game[selectedRow][selectedCol];

            // If the same piece is clicked again, do nothing (keep it selected)
            if (row === selectedRow && col === selectedCol) {
                return; // Do not deselect
            }

            // If a different square is clicked, check if the move is valid
            if (canMove(selectedPiece, selectedRow, selectedCol, row, col)) {
                makeMove(game, row, col, selectedRow, selectedCol);
            }

            // Deselect the square after attempting to move
            setSelectedSquare(null);
        }
    }

    return (
        <div>
            <h2>Chess Game</h2>
            <h3>Current Player: {player}</h3>
            <h4>Time: {formatTime(timer)}</h4>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(8, 60px)' }}>
                {game.map((row, rowIndex) => (
                    row.map((piece, colIndex) => (
                        <Square
                            key={`${rowIndex}-${colIndex}`}
                            value={piece}
                            onClick={() => handleClick(rowIndex, colIndex)}
                            isLight={(rowIndex + colIndex) % 2 === 0}
                            isSelected={selectedSquare && selectedSquare[0] === rowIndex && selectedSquare[1] === colIndex}
                        />
                    ))
                ))}
            </div>
            {!isGameOver && <button onClick={forfeit}>Forfeit</button>}
            <button onClick={restartGame}>Restart</button>
        </div>
    );
}
