<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chessboard with Piece Images</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone@7.10.3/babel.min.js" crossorigin></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react,stage-3">

        // initial state of the board

        const initialGameState = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // load images for pieces
        const pieceImages = {
            'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
            'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
            'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
            'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
            'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
            'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
            'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
            'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
            'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
            'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
            'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
            'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg'
        };

        function Game() {
            const [game, setGame] = React.useState(initialGameState); // state hook for current game board
            const [selectedSquare, setSelectedSquare] = React.useState(null); // state hook for currently selected square
            const [player, setPlayer] = React.useState("White");  // state hook for current turn

            // Handle changing current player
            function changePlayer(isGameOver) {
                if (!isGameOver) {
                    setPlayer(player === "White" ? "Black" : "White");
                } else {
                    setPlayer("Game Over! ".concat(player).concat(" wins!"));
                }
            }

            function forfeit() { // code to make forfeit button work
                setPlayer("Game Over! ".concat(player).concat(" loses!")); // calls end game condition on changePlayer
            }

            function restartGame() { // code to restart game
                window.location.reload(); // refreshes page
            }

            function proposeMove(currentMap, destRow, destCol, selectRow, selectCol, selectedPiece) {  
                if (selectedPiece === 'r') { // check if rook is blocked
                    if (!isBlockedVert(currentMap, Math.max(destRow, selectRow), Math.min(destRow, selectRow), selectCol) && !isBlockedHoriz(currentMap, Math.max(destCol, selectCol), Math.min(destCol, selectCol), selectRow)) {
                        makeMove(currentMap, destRow, destCol, selectRow, selectCol);
                    }
                } else if (selectedPiece === 'b') { // check if bishop is blocked
                    if (((selectRow - destRow) / (selectCol - destCol)) < 0) {
                        if (!isBlockedUpRight(currentMap, Math.max(destCol, selectCol), Math.min(destCol, selectCol), Math.max(destRow, selectRow))) {
                            makeMove(currentMap, destRow, destCol, selectRow, selectCol);
                        }
                    } else if (((selectRow - destRow) / (selectCol - destCol)) > 0) {
                        if (!isBlockedDownRight(currentMap, Math.max(destCol, selectCol), Math.min(destCol, selectCol), Math.min(destRow, selectRow))) {
                            makeMove(currentMap, destRow, destCol, selectRow, selectCol);
                        }
                    }
                } else if (selectedPiece === 'q') { // check if queen is blocked
                    if (selectRow === destRow || selectCol === destCol) {
                        if (!isBlockedVert(currentMap, Math.max(destRow, selectRow), Math.min(destRow, selectRow), selectCol) && !isBlockedHoriz(currentMap, Math.max(destCol, selectCol), Math.min(destCol, selectCol), selectRow) ) {
                            makeMove(currentMap, destRow, destCol, selectRow, selectCol);
                        }
                    } else if (((selectRow - destRow) / (selectCol - destCol)) < 0) {
                        if (!isBlockedUpRight(currentMap, Math.max(destCol, selectCol), Math.min(destCol, selectCol), Math.max(destRow, selectRow))) {
                            makeMove(currentMap, destRow, destCol, selectRow, selectCol);
                        }
                    } else if (((selectRow - destRow) / (selectCol - destCol)) > 0) {
                        if (!isBlockedDownRight(currentMap, Math.max(destCol, selectCol), Math.min(destCol, selectCol), Math.min(destRow, selectRow))) {
                            makeMove(currentMap, destRow, destCol, selectRow, selectCol);
                        }
                    }
                } else { // check for every other piece
                    makeMove(currentMap, destRow, destCol, selectRow, selectCol);
                }
            }

            function makeMove(currentMap, destRow, destCol, selectRow, selectCol) {
                let isGameOver = false;
                let map = currentMap.slice(); // copy array
                map[destRow][destCol] = map[selectRow][selectCol];
                map[selectRow][selectCol] = '';
                setGame(map); // update board
                if (map[destRow][destCol] === 'K' || map[destRow][destCol] === 'k') { // check for end game condition
                    isGameOver = true;
                }
                changePlayer(isGameOver); // update player
            }

            function isBlockedVert(currentMap, largerRow, smallerRow, selectCol) { // check if vertical movement is blocked
                for (let i = smallerRow + 1; i < largerRow; i++) {
                    if (currentMap[i][selectCol] !== '') {
                        return true;
                    }
                }
                return false;
            }

            function isBlockedHoriz(currentMap, largerCol, smallerCol, selectRow) { // check if horizontal movement is blocked
                for (let i = smallerCol + 1; i < largerCol; i++) {
                    if (currentMap[selectRow][i] !== '') {
                        return true;
                    }
                }
                return false;
            }

            function isBlockedUpRight(currentMap, largerCol, smallerCol, largerRow) { // check if diagonal movement (up-right) is blocked
                for (let i = smallerCol + 1; i < largerCol; i++) {
                    if (currentMap[largerRow - i + smallerCol][i] !== '') {
                        return true;
                    }
                }
                return false;
            }

            function isBlockedDownRight(currentMap, largerCol, smallerCol, smallerRow) { // check if diagonal movement (down-right) is blocked
                for (let i = smallerCol + 1; i < largerCol; i++) {
                    if (currentMap[i - smallerCol + smallerRow][i] !== '') {
                        return true;
                    }
                }
                return false;
            }

            // Handle square click
            function handleClick(row, col) {
                if (!selectedSquare) {
                    if ((player === "White" && game[row][col] !== game[row][col].toLowerCase() && game[row][col] !== "") || (player === "Black" && game[row][col] === game[row][col].toLowerCase())) {
                        setSelectedSquare([row, col]); // set selected square if valid square selected
                    }
                } else {
                    const [selectedRow, selectedCol] = selectedSquare;
                    proposeMove(game, row, col, selectedRow, selectedCol, game[selectedRow][selectedCol].toLowerCase());
                    setSelectedSquare(null); // after valid move reset selected square to null
                }
            }

            return (
                <div>
                    <h2>Chess Game</h2>
                    <h3>Current Player: {player}</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(8, 60px)', gap: '2px', margin: '20px 0' }}>
                        {game.map((row, rowIndex) => (
                            row.map((piece, colIndex) => (
                                <Square
                                    key={`${rowIndex}-${colIndex}`}
                                    value={piece}
                                    onClick={() => handleClick(rowIndex, colIndex)}
                                    isLight={(rowIndex + colIndex) % 2 === 0}
                                    isSelected={selectedSquare && selectedSquare[0] === rowIndex && selectedSquare[1] === colIndex}
                                />
                            ))
                        ))}
                    </div>
                    <button onClick={forfeit}>Forfeit</button>
                    <button onClick={restartGame}>Restart Game</button>
                </div>
            );
        }

        // Define the Square component
        function Square({ value, onClick, isLight, isSelected }) {
            const pieceImage = value ? pieceImages[value] : null;
            return (
                <div
                    onClick={onClick}
                    style={{
                        width: '60px',
                        height: '60px',
                        backgroundColor: isSelected ? 'yellow' : isLight ? '#f0d9b5' : '#b58863',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        border: '1px solid #333',
                        cursor: 'pointer'
                    }}
                >
                    {pieceImage && <img src={pieceImage} alt={value} style={{ width: '50px', height: '50px' }} />}
                </div>
            );
        }

        // Render the Game component into the root div
        ReactDOM.render(<Game />, document.getElementById('root'));

    </script>
</body>
</html>
